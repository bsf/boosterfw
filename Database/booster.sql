/******************************************************************************/
/***          Generated by IBExpert 2010.01.22 13.08.2011 8:55:06           ***/
/******************************************************************************/

SET NAMES WIN1251;

CREATE DATABASE 'localhost:C:\FB\Db\BOOSTER2.GDB'
USER 'SYSDBA' PASSWORD 'masterkey'
PAGE_SIZE 8192
DEFAULT CHARACTER SET WIN1251;



/******************************************************************************/
/***                               Generators                               ***/
/******************************************************************************/

CREATE GENERATOR MSG_GEN;


/******************************************************************************/
/***                               Exceptions                               ***/
/******************************************************************************/

CREATE EXCEPTION RAISE 'ERROR';



SET TERM ^ ; 



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/

CREATE OR ALTER PROCEDURE ENTC_EV_UI_LIST
RETURNS (
    URI VARCHAR(50),
    UICLASS VARCHAR(50),
    ENTITYNAME VARCHAR(50),
    VIEWNAME VARCHAR(50),
    TITLE VARCHAR(50),
    GRP VARCHAR(50),
    OPTIONS VARCHAR(1024),
    PARAMS VARCHAR(1024),
    OUTS VARCHAR(1024),
    CATEGORY VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE INF_EV_SETTING_CHECK (
    NAME_ VARCHAR(50),
    USERNAME_ VARCHAR(50))
RETURNS (
    COMMON_EXISTS INTEGER,
    USER_EXISTS INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE INF_EV_SETTING_GET (
    NAME_ VARCHAR(50),
    USERNAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE INF_EV_SETTING_SET (
    NAME_ VARCHAR(50),
    USERNAME_ VARCHAR(50),
    VALI_ INTEGER,
    VALS_ VARCHAR(250),
    VALN_ DOUBLE PRECISION,
    VALD_ DATE)
AS
BEGIN
  EXIT;
END^


CREATE OR ALTER PROCEDURE INF_SP_ENUM_GET (
    TABLENAME_ VARCHAR(50),
    FIELDNAME_ VARCHAR(50),
    ID_ INTEGER)
RETURNS (
    ID INTEGER,
    NAME VARCHAR(50),
    CODE VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE INF_SP_ENUM_LOOKUP (
    TABLENAME_ VARCHAR(50),
    FIELDNAME_ VARCHAR(50),
    SHOWNONE_ INTEGER)
RETURNS (
    ID INTEGER,
    NAME VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE INF_SP_SETTING (
    NAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE INF_SP_SETTING_ (
    NAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE INF_SP_SETTING2 (
    NAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE MSG_SP_BOX_POP (
    FROM_ID_ INTEGER)
RETURNS (
    ID INTEGER,
    SDAT DATE,
    SENDER VARCHAR(38),
    TOPIC VARCHAR(50),
    TXT VARCHAR(250))
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE MSG_SP_BOX_PUSH (
    RECEIVER_ VARCHAR(38),
    TOPIC_ VARCHAR(50),
    TXT_ VARCHAR(250))
AS
BEGIN
  EXIT;
END^


CREATE OR ALTER PROCEDURE SEC_EO_PERM_STATE_GET (
    PERMID VARCHAR(38),
    USERID VARCHAR(38),
    RESID VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE SEC_EO_PERM_STATE_SET (
    PERMID VARCHAR(38),
    USERID VARCHAR(38),
    RESID VARCHAR(38),
    STATE INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE OR ALTER PROCEDURE SEC_EO_POLICY_RESET (
    POLID_ VARCHAR(38))
AS
BEGIN
  EXIT;
END^


CREATE OR ALTER PROCEDURE SEC_EO_POLICY_STATE_GET (
    POLID VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE SEC_EO_POLICY_STATE_SET (
    POLID VARCHAR(38),
    STATE INTEGER)
AS
BEGIN
  EXIT;
END^


CREATE OR ALTER PROCEDURE SEC_EV_PERM_EFFECTIVE (
    POLID_ VARCHAR(38),
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    USERID VARCHAR(38),
    USERNAME VARCHAR(50),
    PERM VARCHAR(50),
    STATE INTEGER,
    INHERITBY_PERM VARCHAR(50),
    INHERITBY_RESID VARCHAR(38))
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE SEC_EV_PERM_EFFECTIVE_ (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER,
    PERMID VARCHAR(38),
    RESID VARCHAR(38))
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE SEC_EV_PERM_LIST (
    POLID VARCHAR(38))
RETURNS (
    PERMID VARCHAR(38),
    NAME VARCHAR(50),
    DESCRIPTION VARCHAR(250),
    INHERITBY VARCHAR(50))
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE SEC_EV_POLICY_LIST (
    PARENTID VARCHAR(38))
RETURNS (
    POLID VARCHAR(38),
    NAME VARCHAR(50),
    RES_PROVID VARCHAR(38))
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE SEC_SP_PERM_CHECK (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE SEC_SP_PERM_DEMAND (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
AS
BEGIN
  EXIT;
END^


CREATE OR ALTER PROCEDURE SEC_SP_PERM_DEMAND_USERS (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    USERID VARCHAR(38))
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE SEC_SP_PERM_DEMAND2 (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE UTL_SP_STRING_LEN (
    STRG_IN VARCHAR(32765))
RETURNS (
    STRG_LEN SMALLINT)
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE UTL_SP_STRING_REPLACE (
    STR_IN VARCHAR(1024),
    STR_SEARCH VARCHAR(1024),
    STR_REPLACE VARCHAR(1024))
RETURNS (
    STR_OUT VARCHAR(1024))
AS
BEGIN
  SUSPEND;
END^


CREATE OR ALTER PROCEDURE UTL_SP_STRING_SUB (
    STR_IN VARCHAR(32765),
    STR_BEG SMALLINT,
    STR_LEN SMALLINT)
RETURNS (
    STR_OUT VARCHAR(32765))
AS
BEGIN
  SUSPEND;
END^



SET TERM ; ^



/******************************************************************************/
/***                                 Tables                                 ***/
/******************************************************************************/



CREATE TABLE ENT_ENTITIES (
    ENTITYNAME   VARCHAR(38) NOT NULL,
    SCHEMENAME   VARCHAR(38),
    IS_SCHEME    INTEGER DEFAULT 0 NOT NULL,
    DESCRIPTION  VARCHAR(250)
);


CREATE TABLE ENT_FIELDS (
    ENTITYNAME      VARCHAR(38) NOT NULL,
    VIEWNAME        VARCHAR(38) NOT NULL,
    FIELDNAME       VARCHAR(38) NOT NULL,
    BAND            VARCHAR(50),
    TITLE           VARCHAR(50),
    VISIBLE         INTEGER DEFAULT 1 NOT NULL,
    READONLY        INTEGER DEFAULT 0 NOT NULL,
    EDITOR          VARCHAR(50),
    EDITOR_OPTIONS  VARCHAR(1024),
    OPTIONS         VARCHAR(1024),
    REQ             INTEGER DEFAULT 0 NOT NULL
);


CREATE TABLE ENT_OPERS (
    ENTITYNAME  VARCHAR(38) NOT NULL,
    OPERNAME    VARCHAR(38) NOT NULL,
    SQL_TEXT    VARCHAR(1024),
    IS_SELECT   INTEGER DEFAULT 0,
    OPTIONS     VARCHAR(1024)
);


CREATE TABLE ENT_VIEW_LINKS (
    ENTITYNAME         VARCHAR(38) NOT NULL,
    VIEWNAME           VARCHAR(38) NOT NULL,
    LINKED_ENTITYNAME  VARCHAR(38) NOT NULL,
    LINKED_VIEWNAME    VARCHAR(38) NOT NULL,
    LINK_KIND          INTEGER DEFAULT 1 NOT NULL,
    LINKED_FIELD       VARCHAR(38)
);


CREATE TABLE ENT_VIEWS (
    ENTITYNAME   VARCHAR(38) NOT NULL,
    VIEWNAME     VARCHAR(38) NOT NULL,
    SQL_SELECT   VARCHAR(1024),
    SQL_INSERT   VARCHAR(1024),
    SQL_UPDATE   VARCHAR(1024),
    SQL_DELETE   VARCHAR(1024),
    SQL_REFRESH  VARCHAR(1024),
    READONLY     INTEGER DEFAULT 1 NOT NULL,
    PKEY         VARCHAR(38),
    OPTIONS      VARCHAR(1024),
    IS_EXEC      INTEGER DEFAULT 0 NOT NULL
);


CREATE TABLE ENTC_CMD (
    URI           VARCHAR(50) NOT NULL,
    CMD           VARCHAR(50) NOT NULL,
    CAPTION       VARCHAR(50) NOT NULL,
    IDX           INTEGER DEFAULT 0 NOT NULL,
    GRP           VARCHAR(50),
    DEF           INTEGER DEFAULT 0 NOT NULL,
    HANDLER_KIND  INTEGER NOT NULL,
    HANDLER       VARCHAR(50),
    CMD_DATA      VARCHAR(1024),
    OPTIONS       VARCHAR(1024)
);


CREATE TABLE ENTC_GRP (
    GRP  VARCHAR(50) NOT NULL,
    IDX  INTEGER
);


CREATE TABLE ENTC_UI (
    URI         VARCHAR(50) NOT NULL,
    UICLASS     VARCHAR(50) NOT NULL,
    ENTITYNAME  VARCHAR(50) NOT NULL,
    VIEWNAME    VARCHAR(50),
    TITLE       VARCHAR(50) NOT NULL,
    GRP         VARCHAR(50),
    OPTIONS     VARCHAR(1024),
    IDX         INTEGER,
    PARAMS      VARCHAR(1024),
    OUTS        VARCHAR(50),
    CATEGORY    VARCHAR(50)
);


CREATE TABLE ENTC_UICLASS (
    UICLASS      VARCHAR(50) NOT NULL,
    VIEWNAME     VARCHAR(50) NOT NULL,
    DESCRIPTION  VARCHAR(250)
);


CREATE TABLE INF_DICT (
    TABLENAME  VARCHAR(50) NOT NULL,
    NAME       VARCHAR(50) NOT NULL
);


CREATE TABLE INF_ENUM (
    TABLENAME  VARCHAR(50) NOT NULL,
    FIELDNAME  VARCHAR(50) NOT NULL,
    ID         INTEGER NOT NULL,
    NAME       VARCHAR(50) NOT NULL,
    CODE       VARCHAR(50)
);


CREATE TABLE INF_SETTINGS (
    NAME  VARCHAR(50) NOT NULL,
    USR   VARCHAR(50) NOT NULL,
    VALI  INTEGER,
    VALS  VARCHAR(250),
    VALN  DOUBLE PRECISION,
    VALD  DATE
);


CREATE TABLE INF_SETTINGS_META (
    NAME            VARCHAR(50) NOT NULL,
    TYP             INTEGER NOT NULL,
    TITLE           VARCHAR(50) NOT NULL,
    BAND            VARCHAR(50),
    IS_PREFERENCE   INTEGER DEFAULT 0 NOT NULL,
    EDITOR          VARCHAR(50),
    EDITOR_OPTIONS  VARCHAR(250),
    B52_NAME        VARCHAR(50),
    DEF_VALI        INTEGER,
    DEF_VALS        VARCHAR(250),
    DEF_VALN        DOUBLE PRECISION,
    DEF_VALD        DATE
);


CREATE TABLE MSG_BOXES (
    ID        INTEGER NOT NULL,
    STATUS    INTEGER DEFAULT 0 NOT NULL,
    SENDER    VARCHAR(38) DEFAULT USER NOT NULL,
    RECEIVER  VARCHAR(38) NOT NULL,
    TOPIC     VARCHAR(50) NOT NULL,
    TXT       VARCHAR(250) NOT NULL,
    IDAT      DATE DEFAULT 'NOW' NOT NULL,
    RDAT      DATE
);


CREATE TABLE SEC_ACL (
    PERMID  VARCHAR(38) NOT NULL,
    USERID  VARCHAR(38) NOT NULL,
    RESID   VARCHAR(38) NOT NULL,
    STATE   INTEGER NOT NULL
);


CREATE TABLE SEC_PERMISSIONS (
    PERMID       VARCHAR(38) NOT NULL,
    NAME         VARCHAR(50) NOT NULL,
    POLID        VARCHAR(38) NOT NULL,
    INHERITBY    VARCHAR(38),
    DESCRIPTION  VARCHAR(250)
);


CREATE TABLE SEC_POLICIES (
    POLID           VARCHAR(38) NOT NULL,
    NAME            VARCHAR(50) NOT NULL,
    PARENTID        VARCHAR(38),
    STATE           INTEGER NOT NULL,
    USE_RES         INTEGER NOT NULL,
    RES_PROVID      VARCHAR(38),
    RES_PARENT_SQL  VARCHAR(1024)
);


CREATE TABLE SEC_USER_ROLES (
    USERID  VARCHAR(38) NOT NULL,
    ROLEID  VARCHAR(38) NOT NULL
);


CREATE TABLE SEC_USERS (
    USERID  VARCHAR(38) NOT NULL,
    NAME    VARCHAR(50) NOT NULL,
    ISROLE  INTEGER DEFAULT 0 NOT NULL
);


INSERT INTO ENTC_UICLASS (UICLASS, VIEWNAME, DESCRIPTION) VALUES ('IEntityListView', 'List', '{Selector;SelectorInfo,NewURI,ItemURI}');
INSERT INTO ENTC_UICLASS (UICLASS, VIEWNAME, DESCRIPTION) VALUES ('IEntityJournalView', 'Journal', 'States{Selector;SelectorInfo,NewURI,ItemURI}');
INSERT INTO ENTC_UICLASS (UICLASS, VIEWNAME, DESCRIPTION) VALUES ('IEntityItemView', 'Item', NULL);
INSERT INTO ENTC_UICLASS (UICLASS, VIEWNAME, DESCRIPTION) VALUES ('IEntityNewView', 'New', NULL);
INSERT INTO ENTC_UICLASS (UICLASS, VIEWNAME, DESCRIPTION) VALUES ('IEntityComplexView', 'Head', 'Details{DetailNewURI,DetailItemURI}');
INSERT INTO ENTC_UICLASS (UICLASS, VIEWNAME, DESCRIPTION) VALUES ('IEntityPickListView', 'PickList', NULL);
INSERT INTO ENTC_UICLASS (UICLASS, VIEWNAME, DESCRIPTION) VALUES ('IEntityOrgChartView', 'OrgChart', NULL);
INSERT INTO ENTC_UICLASS (UICLASS, VIEWNAME, DESCRIPTION) VALUES ('IEntitySelectorView', 'Selector', NULL);
INSERT INTO ENTC_UICLASS (UICLASS, VIEWNAME, DESCRIPTION) VALUES ('ISecurityResProvider', 'TopNodes', 'Node;ChildNodes;');
INSERT INTO ENTC_UICLASS (UICLASS, VIEWNAME, DESCRIPTION) VALUES ('IEntityActivity', '-', NULL);
INSERT INTO ENTC_UICLASS (UICLASS, VIEWNAME, DESCRIPTION) VALUES ('IEntityDeskView', 'Desk', NULL);
INSERT INTO ENTC_UICLASS (UICLASS, VIEWNAME, DESCRIPTION) VALUES ('IEntityCollectView', '-', 'CollectInfo;CollectList;CollectItems');

COMMIT WORK;

INSERT INTO ENT_ENTITIES (ENTITYNAME, SCHEMENAME, IS_SCHEME, DESCRIPTION) VALUES ('INF_SETTING', NULL, 0, NULL);
INSERT INTO ENT_ENTITIES (ENTITYNAME, SCHEMENAME, IS_SCHEME, DESCRIPTION) VALUES ('SEC_USER', NULL, 0, NULL);
INSERT INTO ENT_ENTITIES (ENTITYNAME, SCHEMENAME, IS_SCHEME, DESCRIPTION) VALUES ('SEC_POLICY', NULL, 0, NULL);
INSERT INTO ENT_ENTITIES (ENTITYNAME, SCHEMENAME, IS_SCHEME, DESCRIPTION) VALUES ('SEC_PERM', NULL, 0, NULL);
INSERT INTO ENT_ENTITIES (ENTITYNAME, SCHEMENAME, IS_SCHEME, DESCRIPTION) VALUES ('MSG_BOX', NULL, 0, 'Почтовые ящик пользователя');
INSERT INTO ENT_ENTITIES (ENTITYNAME, SCHEMENAME, IS_SCHEME, DESCRIPTION) VALUES ('SEC_PROV_BDS_ACNT', 'SEC_PROV*', 0, 'Провайдер ресурсов - учетные счета');
INSERT INTO ENT_ENTITIES (ENTITYNAME, SCHEMENAME, IS_SCHEME, DESCRIPTION) VALUES ('SEC_PROV_HRS_DEPT', 'SEC_PROV*', 0, 'Провайдер ресурсов - подразделения');
INSERT INTO ENT_ENTITIES (ENTITYNAME, SCHEMENAME, IS_SCHEME, DESCRIPTION) VALUES ('ENTC*', NULL, 1, 'Entity Catalog');
INSERT INTO ENT_ENTITIES (ENTITYNAME, SCHEMENAME, IS_SCHEME, DESCRIPTION) VALUES ('ENTC_UI', 'ENTC*', 0, NULL);
INSERT INTO ENT_ENTITIES (ENTITYNAME, SCHEMENAME, IS_SCHEME, DESCRIPTION) VALUES ('SEC_PROV*', NULL, 1, 'Провайдеры ресурсов');
INSERT INTO ENT_ENTITIES (ENTITYNAME, SCHEMENAME, IS_SCHEME, DESCRIPTION) VALUES ('SEC*', NULL, 1, 'Security Service');
INSERT INTO ENT_ENTITIES (ENTITYNAME, SCHEMENAME, IS_SCHEME, DESCRIPTION) VALUES ('ENT*', NULL, 1, 'Entity Service');

COMMIT WORK;

INSERT INTO ENT_OPERS (ENTITYNAME, OPERNAME, SQL_TEXT, IS_SELECT, OPTIONS) VALUES ('INF_SETTING', 'SET', 'execute procedure inf_ev_setting_set(:name, :username, :vali, :vals, :valn, :vald)', 0, NULL);
INSERT INTO ENT_OPERS (ENTITYNAME, OPERNAME, SQL_TEXT, IS_SELECT, OPTIONS) VALUES ('SEC_USER', 'UserRoleCheck', 'select count(*) status from sec_user_roles  where userid = :userid and roleid = :roleid', 1, NULL);
INSERT INTO ENT_OPERS (ENTITYNAME, OPERNAME, SQL_TEXT, IS_SELECT, OPTIONS) VALUES ('SEC_PERM', 'StateGet', 'select state from sec_eo_perm_state_get(:permid, :userid, :resid)', 1, NULL);
INSERT INTO ENT_OPERS (ENTITYNAME, OPERNAME, SQL_TEXT, IS_SELECT, OPTIONS) VALUES ('SEC_POLICY', 'StateGet', 'select state from sec_eo_policy_state_get(:polid)', 1, NULL);
INSERT INTO ENT_OPERS (ENTITYNAME, OPERNAME, SQL_TEXT, IS_SELECT, OPTIONS) VALUES ('SEC_PERM', 'StateSet', 'execute procedure sec_eo_perm_state_set(:permid, :userid, :resid, :state)', 0, NULL);
INSERT INTO ENT_OPERS (ENTITYNAME, OPERNAME, SQL_TEXT, IS_SELECT, OPTIONS) VALUES ('SEC_POLICY', 'StateSet', 'execute procedure sec_eo_policy_state_set(:polid, :state)', 0, NULL);
INSERT INTO ENT_OPERS (ENTITYNAME, OPERNAME, SQL_TEXT, IS_SELECT, OPTIONS) VALUES ('SEC_USER', 'UserRoleAdd', 'insert into sec_user_roles(userid, roleid) values(:userid, :roleid)', 0, NULL);
INSERT INTO ENT_OPERS (ENTITYNAME, OPERNAME, SQL_TEXT, IS_SELECT, OPTIONS) VALUES ('SEC_USER', 'UserRoleRemove', 'delete from sec_user_roles where userid = :userid and roleid = :roleid', 0, NULL);
INSERT INTO ENT_OPERS (ENTITYNAME, OPERNAME, SQL_TEXT, IS_SELECT, OPTIONS) VALUES ('SEC_PERM', 'Check', 'select state from sec_sp_perm_check(:permid, :userid, :resid)', 1, NULL);
INSERT INTO ENT_OPERS (ENTITYNAME, OPERNAME, SQL_TEXT, IS_SELECT, OPTIONS) VALUES ('SEC_POLICY', 'Reset', 'execute procedure sec_eo_policy_reset(:polid)', 0, NULL);
INSERT INTO ENT_OPERS (ENTITYNAME, OPERNAME, SQL_TEXT, IS_SELECT, OPTIONS) VALUES ('MSG_BOX', 'POP', 'select * from msg_sp_box_pop(:last_id)', 1, NULL);
INSERT INTO ENT_OPERS (ENTITYNAME, OPERNAME, SQL_TEXT, IS_SELECT, OPTIONS) VALUES ('MSG_BOX', 'PUSH', 'execute procedure msg_sp_box_push(:receiver, :topic, :txt)', 0, NULL);
INSERT INTO ENT_OPERS (ENTITYNAME, OPERNAME, SQL_TEXT, IS_SELECT, OPTIONS) VALUES ('MSG_BOX', 'MARK', 'update msg_boxes set status = 1 where id = :id', 0, NULL);

COMMIT WORK;

INSERT INTO ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC) VALUES ('INF_SETTING', 'META', 'select * from inf_settings_meta order by title', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0);
INSERT INTO ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC) VALUES ('INF_SETTING', 'GET', 'select * from inf_ev_setting_get(:name, :username)', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0);
INSERT INTO ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC) VALUES ('INF_SETTING', 'CHECK', 'select * from inf_ev_setting_check(:name, :username)', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0);
INSERT INTO ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC) VALUES ('SEC_POLICY', 'List', 'select * from sec_ev_policy_list(:ParentID) order by name', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0);
INSERT INTO ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC) VALUES ('SEC_USER', 'List', 'select userid, name, isrole from sec_users order by name', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0);
INSERT INTO ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC) VALUES ('SEC_PERM', 'List', 'select * from sec_ev_perm_list(:polid)', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0);
INSERT INTO ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC) VALUES ('SEC_USER', 'Item', 'select userid, name, isrole from sec_users where userid= :userid', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0);
INSERT INTO ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC) VALUES ('SEC_PERM', 'Effective', 'select * from sec_ev_perm_effective(:polid, :permid, :resid)', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0);
INSERT INTO ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC) VALUES ('ENTC_UI', 'List', 'select * from entc_ev_ui_list', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0);
INSERT INTO ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC) VALUES ('ENTC_UI', 'Commands', 'select * from entc_cmd where uri = :uri order by idx', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0);

COMMIT WORK;

INSERT INTO INF_DICT (TABLENAME, NAME) VALUES ('ENT_', 'Entities');
INSERT INTO INF_DICT (TABLENAME, NAME) VALUES ('ENTC_', 'Entity UI');
INSERT INTO INF_DICT (TABLENAME, NAME) VALUES ('INF_', 'Infrastructure');
INSERT INTO INF_DICT (TABLENAME, NAME) VALUES ('MSG_', 'Messaging');
INSERT INTO INF_DICT (TABLENAME, NAME) VALUES ('SEC_', 'Security');

COMMIT WORK;

INSERT INTO SEC_POLICIES (POLID, NAME, PARENTID, STATE, USE_RES, RES_PROVID, RES_PARENT_SQL) VALUES ('App.Activities', 'Доступ к функциям программы', NULL, 1, 1, 'security.resprovider.app.activities', NULL);
INSERT INTO SEC_POLICIES (POLID, NAME, PARENTID, STATE, USE_RES, RES_PROVID, RES_PARENT_SQL) VALUES ('App.Reports.Engine', 'Подстистема "Отчеты"', NULL, 1, 0, NULL, NULL);
INSERT INTO SEC_POLICIES (POLID, NAME, PARENTID, STATE, USE_RES, RES_PROVID, RES_PARENT_SQL) VALUES ('BUILT-IN', 'Администраторы', NULL, 1, 0, NULL, NULL);
INSERT INTO SEC_POLICIES (POLID, NAME, PARENTID, STATE, USE_RES, RES_PROVID, RES_PARENT_SQL) VALUES ('App.Reports', 'Доступ к отчетам', 'App.Reports.Engine', 1, 1, 'security.resprovider.app.reports', NULL);

COMMIT WORK;

INSERT INTO SEC_PERMISSIONS (PERMID, NAME, POLID, INHERITBY, DESCRIPTION) VALUES ('app.activity.execute', 'Выполнить', 'App.Activities', NULL, NULL);
INSERT INTO SEC_PERMISSIONS (PERMID, NAME, POLID, INHERITBY, DESCRIPTION) VALUES ('app.report.execute', 'Выполнить', 'App.Reports', NULL, NULL);
INSERT INTO SEC_PERMISSIONS (PERMID, NAME, POLID, INHERITBY, DESCRIPTION) VALUES ('app.report.engine.access', 'Конструирование отчетов', 'App.Reports.Engine', NULL, NULL);
INSERT INTO SEC_PERMISSIONS (PERMID, NAME, POLID, INHERITBY, DESCRIPTION) VALUES ('app.report.setup', 'Настроить', 'App.Reports', NULL, NULL);
INSERT INTO SEC_PERMISSIONS (PERMID, NAME, POLID, INHERITBY, DESCRIPTION) VALUES ('builtin.unrestricted', 'Неограниченный доступ', 'BUILT-IN', NULL, NULL);

COMMIT WORK;

INSERT INTO SEC_USERS (USERID, NAME, ISROLE) VALUES ('SYSDBA', 'SYSDBA', 0);

COMMIT WORK;

INSERT INTO SEC_ACL (PERMID, USERID, RESID, STATE) VALUES ('builtin.unrestricted', 'SYSDBA', ' ', 1);

COMMIT WORK;



/******************************************************************************/
/***                              Primary Keys                              ***/
/******************************************************************************/

ALTER TABLE ENTC_CMD ADD CONSTRAINT PK_ENTC_CMD PRIMARY KEY (URI, CMD);
ALTER TABLE ENTC_GRP ADD CONSTRAINT PK_ENTC_GRP PRIMARY KEY (GRP);
ALTER TABLE ENTC_UI ADD CONSTRAINT PK_ENTC_UI PRIMARY KEY (URI);
ALTER TABLE ENTC_UICLASS ADD CONSTRAINT PK_ENTC_UICLASS PRIMARY KEY (UICLASS);
ALTER TABLE ENT_ENTITIES ADD CONSTRAINT PK_ENT_ENTITIES PRIMARY KEY (ENTITYNAME);
ALTER TABLE ENT_FIELDS ADD CONSTRAINT PK_ENT_FIELDS PRIMARY KEY (ENTITYNAME, VIEWNAME, FIELDNAME);
ALTER TABLE ENT_OPERS ADD CONSTRAINT PK_ENT_OPERS PRIMARY KEY (ENTITYNAME, OPERNAME);
ALTER TABLE ENT_VIEWS ADD CONSTRAINT PK_ENT_VIEWS PRIMARY KEY (ENTITYNAME, VIEWNAME);
ALTER TABLE ENT_VIEW_LINKS ADD CONSTRAINT PK_ENT_VIEW_LINKS PRIMARY KEY (ENTITYNAME, VIEWNAME, LINKED_ENTITYNAME, LINKED_VIEWNAME, LINK_KIND);
ALTER TABLE INF_DICT ADD CONSTRAINT PK_INF_DICT PRIMARY KEY (TABLENAME);
ALTER TABLE INF_ENUM ADD CONSTRAINT PK_INF_ENUM PRIMARY KEY (TABLENAME, FIELDNAME, ID);
ALTER TABLE INF_SETTINGS ADD CONSTRAINT PK_INF_SETTINGS PRIMARY KEY (NAME, USR);
ALTER TABLE INF_SETTINGS_META ADD CONSTRAINT PK_INF_SETTINGS_META PRIMARY KEY (NAME);
ALTER TABLE MSG_BOXES ADD CONSTRAINT PK_MSG_BOXES PRIMARY KEY (ID);
ALTER TABLE SEC_ACL ADD CONSTRAINT PK_SEC_ACL PRIMARY KEY (PERMID, USERID, RESID);
ALTER TABLE SEC_PERMISSIONS ADD CONSTRAINT PK_SEC_PERMISSIONS PRIMARY KEY (PERMID);
ALTER TABLE SEC_POLICIES ADD CONSTRAINT PK_SEC_POLICIES PRIMARY KEY (POLID);
ALTER TABLE SEC_USERS ADD CONSTRAINT PK_SEC_USERS PRIMARY KEY (USERID);
ALTER TABLE SEC_USER_ROLES ADD CONSTRAINT PK_SEC_USER_ROLES PRIMARY KEY (USERID, ROLEID);


/******************************************************************************/
/***                              Foreign Keys                              ***/
/******************************************************************************/

ALTER TABLE SEC_ACL ADD CONSTRAINT FK_SEC_ACL_PERM FOREIGN KEY (PERMID) REFERENCES SEC_PERMISSIONS (PERMID);
ALTER TABLE SEC_ACL ADD CONSTRAINT FK_SEC_ACL_USER FOREIGN KEY (USERID) REFERENCES SEC_USERS (USERID);
ALTER TABLE SEC_PERMISSIONS ADD CONSTRAINT FK_SEC_PERMISSIONS_INHERITBY FOREIGN KEY (INHERITBY) REFERENCES SEC_PERMISSIONS (PERMID);
ALTER TABLE SEC_PERMISSIONS ADD CONSTRAINT FK_SEC_PERMISSIONS_POL FOREIGN KEY (POLID) REFERENCES SEC_POLICIES (POLID);
ALTER TABLE SEC_POLICIES ADD CONSTRAINT FK_SEC_POLICIES_PARENT FOREIGN KEY (PARENTID) REFERENCES SEC_POLICIES (POLID);
ALTER TABLE SEC_USER_ROLES ADD CONSTRAINT FK_SEC_USER_ROLES_ROLE FOREIGN KEY (ROLEID) REFERENCES SEC_USERS (USERID);
ALTER TABLE SEC_USER_ROLES ADD CONSTRAINT FK_SEC_USER_ROLES_USER FOREIGN KEY (USERID) REFERENCES SEC_USERS (USERID);


/******************************************************************************/
/***                                Indices                                 ***/
/******************************************************************************/

CREATE INDEX MSG_BOXES_IDX_RECEIVER ON MSG_BOXES (RECEIVER);
CREATE INDEX MSG_BOXES_IDX_STATUS ON MSG_BOXES (STATUS);
CREATE INDEX SEC_PERMISSIONS_IDX_POL ON SEC_PERMISSIONS (POLID);
CREATE INDEX SEC_POLICIES_IDX_PARENT ON SEC_POLICIES (PARENTID);


/******************************************************************************/
/***                                Triggers                                ***/
/******************************************************************************/


SET TERM ^ ;



/******************************************************************************/
/***                          Triggers for tables                           ***/
/******************************************************************************/



/* Trigger: MSG_BOXES_BU */
CREATE OR ALTER TRIGGER MSG_BOXES_BU FOR MSG_BOXES
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.status <> old.status and old.status = 0) then
    new.rdat = 'NOW';
end
^


/* Trigger: SEC_PERMISSIONS_BD */
CREATE OR ALTER TRIGGER SEC_PERMISSIONS_BD FOR SEC_PERMISSIONS
ACTIVE BEFORE DELETE POSITION 0
as
begin
  delete from sec_acl a where a.permid = old.permid;
end
^


/* Trigger: SEC_POLICIES_BD */
CREATE OR ALTER TRIGGER SEC_POLICIES_BD FOR SEC_POLICIES
ACTIVE BEFORE DELETE POSITION 0
as
begin
  if (old.polid = 'BUILD-IN') then
    exception raise 'It is not allowed for built-in policy';
end
^


/* Trigger: SEC_POLICIES_BU */
CREATE OR ALTER TRIGGER SEC_POLICIES_BU FOR SEC_POLICIES
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.polid = 'BUILT-IN' and new.state <> old.state and new.state = 0) then
    exception raise 'It is not allowed for built-in policy';
end
^


/* Trigger: SEC_USERS_BD */
CREATE OR ALTER TRIGGER SEC_USERS_BD FOR SEC_USERS
ACTIVE BEFORE DELETE POSITION 0
as
begin
  delete from sec_acl a where a.userid = old.userid;
  delete from sec_user_roles r where r.userid = old.userid;
  delete from sec_user_roles r where r.roleid = old.userid;
end
^


/* Trigger: SEC_USERS_BI */
CREATE OR ALTER TRIGGER SEC_USERS_BI FOR SEC_USERS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.name is null) then
    new.name = new.userid;
end
^


/* Trigger: SEC_USERS_BU */
CREATE OR ALTER TRIGGER SEC_USERS_BU FOR SEC_USERS
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.name is null) then
    new.name = new.userid;
end
^


SET TERM ; ^



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/


SET TERM ^ ;

CREATE OR ALTER PROCEDURE ENTC_EV_UI_LIST
RETURNS (
    URI VARCHAR(50),
    UICLASS VARCHAR(50),
    ENTITYNAME VARCHAR(50),
    VIEWNAME VARCHAR(50),
    TITLE VARCHAR(50),
    GRP VARCHAR(50),
    OPTIONS VARCHAR(1024),
    PARAMS VARCHAR(1024),
    OUTS VARCHAR(1024),
    CATEGORY VARCHAR(50))
AS
begin
  for
    select i.uri, i.uiclass, i.entityname, coalesce(i.viewname, c.viewname),
           i.title, i.grp, i.options, i.params, i.outs, i.category
    from entc_ui i
         left join entc_uiclass c on (i.uiclass = c.uiclass)
         left join entc_grp g on (g.grp = i.grp)
    order by g.idx, i.idx, i.title
    into :uri, :uiclass, :entityname, :viewname, :title, :grp, :options, :params, :outs, :category
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE INF_EV_SETTING_CHECK (
    NAME_ VARCHAR(50),
    USERNAME_ VARCHAR(50))
RETURNS (
    COMMON_EXISTS INTEGER,
    USER_EXISTS INTEGER)
AS
begin
  name_ = upper(name_);
  username_ = upper(coalesce(username_, ''));

  common_exists = 0; user_exists = 0;

  if (exists(select * from  inf_settings s
      where s.name = :name_ and s.usr = :username_)) then
    user_exists = 1;

  if (exists(select * from  inf_settings s
      where s.name = :name_ and s.usr = '')) then
    common_exists = 1;

  suspend;
end^


CREATE OR ALTER PROCEDURE INF_EV_SETTING_GET (
    NAME_ VARCHAR(50),
    USERNAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
begin
  name_ = upper(name_);
  username_ = upper(coalesce(username_, ''));
  select s.vali, s.vals, s.valn, s.vald
  from  inf_settings s
  where s.name = :name_ and s.usr = :username_
  into :vali, :vals, :valn, :vald;

  if (vali is null and vals is null and valn is null and vald is null and username_ <> '') then
    select s.vali, s.vals, s.valn, s.vald
    from  inf_settings s
    where s.name = :name_ and s.usr = ''
    into :vali, :vals, :valn, :vald;

  if (vali is null and vals is null and valn is null and vald is null) then
    select s.def_vali, s.def_vals, s.def_valn, s.def_vald
    from  inf_settings_meta s
    where s.name = :name_
    into :vali, :vals, :valn, :vald;

  suspend;
end^


CREATE OR ALTER PROCEDURE INF_EV_SETTING_SET (
    NAME_ VARCHAR(50),
    USERNAME_ VARCHAR(50),
    VALI_ INTEGER,
    VALS_ VARCHAR(250),
    VALN_ DOUBLE PRECISION,
    VALD_ DATE)
AS
begin
  name_ = upper(name_);
  username_ = upper(coalesce(username_, ''));

  if (vali_ is null and vals_ is null and valn_ is null and vald_ is null) then
    delete from inf_settings s
    where s.name = :name_ and s.usr = :username_;
  else
  begin
    if (exists(select * from inf_settings s where s.name = :name_ and usr = :username_)) then
      update inf_settings s
      set s.vali = :vali_, s.vals = :vals_, s.valn = :valn_, s.vald = :vald_
      where s.name = :name_ and s.usr = :username_;
    else
      insert into inf_settings(name, usr, vali, vals, valn, vald)
      values(:name_, :username_, :vali_, :vals_, :valn_, :vald_);
  end
end^


CREATE OR ALTER PROCEDURE INF_SP_ENUM_GET (
    TABLENAME_ VARCHAR(50),
    FIELDNAME_ VARCHAR(50),
    ID_ INTEGER)
RETURNS (
    ID INTEGER,
    NAME VARCHAR(50),
    CODE VARCHAR(50))
AS
begin
  select e.id, e.name, e.code
  from inf_enum e
  where e.tablename = upper(:tablename_)
        and e.fieldname = upper(:fieldname_)
        and e.id = :id_
  into :id, :name, :code;
  suspend;
end^


CREATE OR ALTER PROCEDURE INF_SP_ENUM_LOOKUP (
    TABLENAME_ VARCHAR(50),
    FIELDNAME_ VARCHAR(50),
    SHOWNONE_ INTEGER)
RETURNS (
    ID INTEGER,
    NAME VARCHAR(50))
AS
begin
  for
    select e.id, e.name
    from inf_enum e
    where e.tablename = upper(:tablename_)
          and e.fieldname = upper(:fieldname_)
          and e.id = 0 and :shownone_ = 1
    union
    select e.id, e.name
    from inf_enum e
    where e.tablename = upper(:tablename_)
          and e.fieldname = upper(:fieldname_)
          and e.id <> 0
    into :id, :name
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE INF_SP_SETTING (
    NAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
declare variable setting_title varchar(50);
begin
  select vali, vals, valn, vald from inf_sp_setting2(:name_)
  into :vali, :vals, :valn, :vald;

  if (vali is null and vals is null and valn is null and vald is null) then
  begin
    select m.title from inf_settings_meta m where m.name = :name_
    into :setting_title;

    setting_title = coalesce(setting_title, name_);

    exception raise 'Значение параметра ''' || :setting_title || ''' не определено';
  end

  suspend;
end^


CREATE OR ALTER PROCEDURE INF_SP_SETTING_ (
    NAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
begin
  name_ = upper(name_);

  select s.vali, s.vals, s.valn, s.vald
  from  inf_settings s
  where s.name = :name_ and s.usr = USER
  into :vali, :vals, :valn, :vald;

  if (vali is null and vals is null and valn is null and vald is null) then
    select s.vali, s.vals, s.valn, s.vald
    from  inf_settings s
    where s.name = :name_ and s.usr = ''
    into :vali, :vals, :valn, :vald;

  if (vali is null and vals is null and valn is null and vald is null) then
    select s.def_vali, s.def_vals, s.def_valn, s.def_vald
    from  inf_settings_meta s
    where s.name = :name_
    into :vali, :vals, :valn, :vald;

  suspend;
end^


CREATE OR ALTER PROCEDURE INF_SP_SETTING2 (
    NAME_ VARCHAR(50))
RETURNS (
    VALI INTEGER,
    VALS VARCHAR(250),
    VALN DOUBLE PRECISION,
    VALD DATE)
AS
begin
  name_ = upper(name_);

  select s.vali, s.vals, s.valn, s.vald
  from  inf_settings s
  where s.name = :name_ and s.usr = USER
  into :vali, :vals, :valn, :vald;

  if (vali is null and vals is null and valn is null and vald is null) then
    select s.vali, s.vals, s.valn, s.vald
    from  inf_settings s
    where s.name = :name_ and s.usr = ''
    into :vali, :vals, :valn, :vald;

  if (vali is null and vals is null and valn is null and vald is null) then
    select s.def_vali, s.def_vals, s.def_valn, s.def_vald
    from  inf_settings_meta s
    where s.name = :name_
    into :vali, :vals, :valn, :vald;

  suspend;
end^


CREATE OR ALTER PROCEDURE MSG_SP_BOX_POP (
    FROM_ID_ INTEGER)
RETURNS (
    ID INTEGER,
    SDAT DATE,
    SENDER VARCHAR(38),
    TOPIC VARCHAR(50),
    TXT VARCHAR(250))
AS
declare variable receiver varchar(38);
begin
  receiver = user;
  from_id_ = coalesce(from_id_, 0);

  for
    select m.id, m.idat, coalesce(u.name, m.sender),  m.topic, m.txt
    from msg_boxes m
         left join sec_users u on (u.userid = m.sender)
    where m.receiver = :receiver and m.status = 0 and m.id > :from_id_
    order by m.id
    into :id, :sdat, :sender, :topic, :txt
  do
    suspend;

end^


CREATE OR ALTER PROCEDURE MSG_SP_BOX_PUSH (
    RECEIVER_ VARCHAR(38),
    TOPIC_ VARCHAR(50),
    TXT_ VARCHAR(250))
AS
declare variable id integer;
begin
  receiver_ = upper(receiver_);
  id = gen_id(msg_gen, 1);
  insert into msg_boxes(id, receiver, topic, txt)
  values(:id, :receiver_, :topic_, :txt_);

end^


CREATE OR ALTER PROCEDURE SEC_EO_PERM_STATE_GET (
    PERMID VARCHAR(38),
    USERID VARCHAR(38),
    RESID VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
begin
  resid = coalesce(resid, '');
  select state
  from sec_acl p
  where p.resid = :resid and p.userid = :userid and p.permid = :permid
  into :state;
  state = coalesce(state, 0);
  suspend;
end^


CREATE OR ALTER PROCEDURE SEC_EO_PERM_STATE_SET (
    PERMID VARCHAR(38),
    USERID VARCHAR(38),
    RESID VARCHAR(38),
    STATE INTEGER)
AS
begin
  resid = coalesce(resid, '');

  if (state = 0) then
    delete from sec_acl p
       where p.resid = :resid and p.userid = :userid and p.permid = :permid;
  else
  begin
    if (exists(select * from sec_acl p
              where p.resid = :resid
                    and p.userid = :userid and p.permid = :permid)) then
     update sec_acl p
     set p.state = :state
     where p.resid = :resid and p.userid = :userid and p.permid = :permid;
    else
      insert into sec_acl(resid, userid, permid, state)
      values (:resid, :userid, :permid, :state);
  end
end^


CREATE OR ALTER PROCEDURE SEC_EO_POLICY_RESET (
    POLID_ VARCHAR(38))
AS
begin
  delete from sec_acl a
  where a.permid in (select p.permid from sec_permissions p where p.polid = :polid_);
end^


CREATE OR ALTER PROCEDURE SEC_EO_POLICY_STATE_GET (
    POLID VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
begin
  select state
  from sec_policies p where p.polid= :polid
  into :state;
  state = coalesce(state, 0);
  suspend;
end^


CREATE OR ALTER PROCEDURE SEC_EO_POLICY_STATE_SET (
    POLID VARCHAR(38),
    STATE INTEGER)
AS
begin
  update sec_policies p
  set p.state = :state
  where p.polid = :polid;
end^


CREATE OR ALTER PROCEDURE SEC_EV_PERM_EFFECTIVE (
    POLID_ VARCHAR(38),
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    USERID VARCHAR(38),
    USERNAME VARCHAR(50),
    PERM VARCHAR(50),
    STATE INTEGER,
    INHERITBY_PERM VARCHAR(50),
    INHERITBY_RESID VARCHAR(38))
AS
declare variable permcheck varchar(38);
declare variable permid varchar(38);
declare variable resid varchar(38);
begin
  permid_ = nullif(permid_, '');
  for
    select userid, name
    from sec_users
    into :userid, :username
  do begin
    for
      select p.permid, p.name
      from sec_policies pl left join sec_permissions p  on (pl.polid = p.polid)
      where pl.polid = :polid_
            and ((:permid_ is null) or (:permid_ is not null and p.permid = :permid_))
      into :permcheck, :perm
    do begin
      state = null;
      inheritby_perm = null;
      inheritby_resid = null;
      permid = null;
      resid = null;
      select p.state, p.permid, p.resid
      from sec_ev_perm_effective_(:permcheck, :userid, :resid_) p
      into :state, :permid, :resid;
      if (state is not null) then
      begin
        if (permid <> permcheck) then
          select name from sec_permissions p
          where p.permid = :permid
          into :inheritby_perm;

        if (coalesce(resid, resid_) <> resid_) then
          inheritby_resid = resid;

        suspend;
      end
    end
  end
end^


CREATE OR ALTER PROCEDURE SEC_EV_PERM_EFFECTIVE_ (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER,
    PERMID VARCHAR(38),
    RESID VARCHAR(38))
AS
declare variable inheritby varchar(38);
declare variable parent_resid varchar(38);
declare variable res_parent_sql varchar(1024);
begin
  resid_ = coalesce(resid_, '');
  permid = permid_;
  resid = resid_;

  for
    select a.state
    from sec_acl a
    where a.resid = :resid_ and a.userid = :userid_ and a.permid = :permid_
    into :state
  do
    if (state in (1, 2)) then
    begin
      suspend;
      exit;
    end

  select p.inheritby, pol.res_parent_sql
  from sec_permissions p left join sec_policies pol on (pol.polid = p.polid)
  where p.permid = :permid_
  into :inheritby, :res_parent_sql;

  if (inheritby is null and res_parent_sql is null) then
  begin
    exit;
  end

  parent_resid = '';
  if (coalesce(res_parent_sql, '') <> '') then
  begin
    res_parent_sql = upper(res_parent_sql);
    execute procedure utl_sp_string_replace(:res_parent_sql, ':RESID', :resid_)
    returning_values :res_parent_sql;
    execute statement res_parent_sql into :parent_resid;
    parent_resid = coalesce(parent_resid, '');

    if (parent_resid <> '') then
      inheritby = permid_;

  end

  if (inheritby is not null) then
  begin
    select state, permid, resid from sec_ev_perm_effective_(:inheritby, :userid_, :parent_resid)
    into :state, :permid, :resid;

    if (state in (1, 2)) then
      suspend;
  end
end^


CREATE OR ALTER PROCEDURE SEC_EV_PERM_LIST (
    POLID VARCHAR(38))
RETURNS (
    PERMID VARCHAR(38),
    NAME VARCHAR(50),
    DESCRIPTION VARCHAR(250),
    INHERITBY VARCHAR(50))
AS
begin
  for
    select p.permid, p.name, p.description, pi.name
    from sec_permissions p
         left join sec_permissions pi on (p.inheritby = pi.permid)
    where p.polid = :polid
    into :permid, :name, :description, :inheritby
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE SEC_EV_POLICY_LIST (
    PARENTID VARCHAR(38))
RETURNS (
    POLID VARCHAR(38),
    NAME VARCHAR(50),
    RES_PROVID VARCHAR(38))
AS
begin
  for
    select p.polid, p.name, p.res_provid
    from sec_policies p
    where p.parentid is null and coalesce(:parentid, '') = ''
    union all
    select p.polid, p.name, p.res_provid
    from sec_policies p
    where p.parentid = :parentid and coalesce(:parentid, '') <> ''
    into :polid, :name, :res_provid
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE SEC_SP_PERM_CHECK (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
declare variable unrestricted_perm varchar(38) = 'builtin.unrestricted' ;
declare variable pol_state integer;
declare variable roleid varchar(38);
declare variable parent_permid varchar(38);
declare variable parent_resid varchar(38);
declare variable res_parent_sql varchar(1024);
begin
  resid_ = coalesce(resid_, '');

  select a.state
  from sec_acl a
  where a.permid = :unrestricted_perm and a.userid = :userid_ and a.resid = ''
        and a.state = 1
  into :state;

  if (coalesce(state, 0) = 1) then
  begin
    suspend;
    exit;
  end

  select first 1 a.state
  from sec_acl a
       left join sec_user_roles r on (a.userid = r.roleid)
  where a.permid = :unrestricted_perm and r.userid = :userid_ and a.resid = ''
        and a.state = 1
  into :state;

  if (coalesce(state, 0) = 1) then
  begin
    suspend;
    exit;
  end

  select p.inheritby, pol.res_parent_sql, pol.state
  from sec_permissions p left join sec_policies pol on (pol.polid = p.polid)
  where p.permid = :permid_
  into :parent_permid, :res_parent_sql, :pol_state;

  if (pol_state <> 1) then
  begin
    state = 1;
    suspend;
    exit;
  end

  for
    select a.state
    from sec_acl a
    where a.resid = :resid_ and a.userid = :userid_ and a.permid = :permid_
    into :state
  do
    if (state in (1, 2)) then
    begin
      suspend;
      exit;
    end

  for
    select r.roleid
    from sec_user_roles r
    where r.userid = :userid_
    into :roleid
  do begin
    select a.state
    from sec_acl a
    where a.resid = :resid_ and a.userid = :roleid and a.permid = :permid_
    into :state;

    if (state in (1, 2)) then
    begin
      suspend;
      exit;
    end
  end

  if (parent_permid is null and res_parent_sql is null) then
  begin
    state = 0;
    suspend;
    exit;
  end

  parent_resid = '';
  if (coalesce(res_parent_sql, '') <> '') then
  begin
    res_parent_sql = upper(res_parent_sql);
    execute procedure utl_sp_string_replace(:res_parent_sql, ':RESID', :resid_)
    returning_values :res_parent_sql;
    execute statement res_parent_sql into :parent_resid;
    parent_resid = coalesce(parent_resid, '');

    if (parent_resid <> '') then
      parent_permid = permid_;

  end

  if (parent_permid is not null) then
  begin
    select state from sec_sp_perm_check(:parent_permid, :userid_, :parent_resid)
    into :state;
    suspend;
    exit;
  end
  else
  begin
    state = 0;
    suspend;
    exit;
  end
end^


CREATE OR ALTER PROCEDURE SEC_SP_PERM_DEMAND (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
AS
declare variable userid  varchar(38);
declare variable pstate integer;
declare variable pname varchar(250);
begin
  userid = user;
  select state from sec_sp_perm_check(:permid_, :userid, :resid_)
  into :pstate;

  if (pstate <> 1) then
  begin
    select name from sec_permissions p where p.permid = :permid_
    into :pname;

    pname = coalesce(pname, permid_);

    pname = 'Нет разрешения на: ' || pname;
    exception raise :pname;
--    execute procedure utl_sp_raise(:pname);
  end
end^


CREATE OR ALTER PROCEDURE SEC_SP_PERM_DEMAND_USERS (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    USERID VARCHAR(38))
AS
declare variable state integer;
begin
  for
    select u.userid
    from sec_users u
    where u.isrole = 0
    into :userid 
  do begin
    select state from sec_sp_perm_check(:permid_, :userid, :resid_)
    into :state;

    if (state = 1) then suspend;
  end
end^


CREATE OR ALTER PROCEDURE SEC_SP_PERM_DEMAND2 (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
declare variable userid  varchar(38);
begin
  userid = user;
  select state from sec_sp_perm_check(:permid_, :userid, :resid_)
  into :state;
  suspend;
end^


CREATE OR ALTER PROCEDURE UTL_SP_STRING_LEN (
    STRG_IN VARCHAR(32765))
RETURNS (
    STRG_LEN SMALLINT)
AS
    begin
      /*
        get string length
      */

      if (strg_in is null)
        then
          strg_len = null;
        else
          begin
            strg_len = 0;
            while (strg_in || '.'  <> '.')
              do
                begin
                  strg_in = substring( strg_in from 2);
                  strg_len = strg_len + 1;
                end
          end

      suspend;
    end^


CREATE OR ALTER PROCEDURE UTL_SP_STRING_REPLACE (
    STR_IN VARCHAR(1024),
    STR_SEARCH VARCHAR(1024),
    STR_REPLACE VARCHAR(1024))
RETURNS (
    STR_OUT VARCHAR(1024))
AS
declare variable str_beg integer;
declare variable str_comp varchar(1024);
declare variable str_pre varchar(1024);
declare variable str_pst varchar(1024);
declare variable str_len_orig smallint;
declare variable str_len_srch smallint;
declare variable str_len_repl smallint;
declare variable str_replaced varchar(1024);
begin
      /*
        replace substring
          str_beg : 1 ..

        examples:
          execute procedure lib_string_replace :strg_in, 1, 'to_replace', 'replacement'
                                               returning_values :strg_out, :strg_replaced;

          select my_table.my_text,
                   (select lib_string_replace.strg_out
                      from lib_string_replace( my_table.my_text, 1, 'MEMO:', 'Memo:'))
            from my_table;

          update my_table
            set my_table.my_text =
                  (select lib_string_replace.strg_out
                     from lib_string_replace( my_table.my_text, 1, 'MEMO:', 'Memo:'));
      */

  str_beg = 1;
  if ((str_in is null)
       or (str_beg is null)
       or (str_beg <= 0)
       or (str_search is null)
       or (str_replace is null)) then
  begin
    str_out = null;
    str_replaced = null;
  end
  else
  begin
    str_replaced = 0;
    execute procedure utl_sp_string_len :str_in returning_values :str_len_orig;
--    str_len_orig = strlen(str_in);

    execute procedure utl_sp_string_len :str_search returning_values :str_len_srch;
--    str_len_srch = strlen(str_search);

    execute procedure utl_sp_string_len :str_replace  returning_values :str_len_repl;
--    str_len_repl = strlen(str_replace);

    while (str_len_srch + str_beg - 1 <= str_len_orig) do
    begin
      execute procedure utl_sp_string_len :str_in returning_values :str_len_orig;
--      str_len_orig = strlen(str_in);

--      execute procedure lib_string_sub :strg_in, :strg_beg, strg_len_srch returning_values :strg_comp;
      execute procedure utl_sp_string_sub :str_in, :str_beg, str_len_srch returning_values :str_comp;

      if (str_comp || '.' = str_search || '.') then
      begin
        execute procedure utl_sp_string_sub :str_in, 1, :str_beg - 1
          returning_values :str_pre;

        execute procedure utl_sp_string_sub :str_in, :str_beg + :str_len_srch,
                    :str_len_orig - (:str_beg + :str_len_srch) + 1
                                                         returning_values :str_pst;

        str_in = coalesce(str_pre, '') || str_replace || coalesce(str_pst, '');

        str_beg = str_beg + str_len_repl - str_len_srch;

        str_replaced = str_replaced + 1;
      end

      str_beg = str_beg + 1;
    end

    str_out = str_in;
  end

  suspend;
end^


CREATE OR ALTER PROCEDURE UTL_SP_STRING_SUB (
    STR_IN VARCHAR(32765),
    STR_BEG SMALLINT,
    STR_LEN SMALLINT)
RETURNS (
    STR_OUT VARCHAR(32765))
AS
declare variable str_chr char( 1);
declare variable str_cpy varchar( 32765);

begin
  /*
     get substring
     strg_beg : 1 ..
  */

  if ((str_in is null)
     or (str_beg is null)
     or (str_beg <= 0)
     or (str_len is null)
     or (str_len <= 0))
  then
    str_out = null;
  else
  begin
    str_cpy = str_in;
    while (1 < str_beg) do
    begin
      str_cpy = substring( str_cpy from 2);
      str_beg = str_beg - 1;
    end

    str_out = '';
    while (0 < str_len) do
    begin
      str_chr = substring( str_cpy from 1 for 1);
      if (str_chr || '.' <> '.') then
      begin
        str_out = str_out || str_chr;
        str_cpy = substring( str_cpy from 2);
        str_len = str_len - 1;
      end
      else
      begin
        str_len = 0;
      end
    end
  end

  suspend;
end^



SET TERM ; ^
