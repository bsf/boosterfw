/******************************************************************************/
/***          Generated by IBExpert 2012.03.13 16.06.2012 15:49:09          ***/
/******************************************************************************/

/******************************************************************************/
/***      Following SET SQL DIALECT is just for the Database Comparer       ***/
/******************************************************************************/


/******************************************************************************/
/***                               Exceptions                               ***/
/******************************************************************************/

CREATE EXCEPTION BFW_SEC_RAISE 'ERROR';



SET TERM ^ ; 



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/

CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_EFFECTIVE (
    POLID_ VARCHAR(38),
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    USERID VARCHAR(38),
    USERNAME VARCHAR(50),
    PERM VARCHAR(50),
    STATE INTEGER,
    INHERITBY_POLID VARCHAR(38),
    INHERITBY_PERM VARCHAR(100),
    INHERITBY_RESID VARCHAR(38))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_EFFECTIVE_ (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER,
    PERMID VARCHAR(38),
    RESID VARCHAR(38))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_EFFECTIVE__ (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38),
    RES_PARENT_SQL_ VARCHAR(1024))
RETURNS (
    STATE INTEGER,
    PERMID VARCHAR(38),
    RESID VARCHAR(38))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_LIST (
    POLID VARCHAR(38))
RETURNS (
    PERMID VARCHAR(38),
    NAME VARCHAR(50),
    DESCRIPTION VARCHAR(250),
    INHERITBY VARCHAR(100))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_STATE_GET (
    PERMID VARCHAR(38),
    USERID VARCHAR(38),
    RESID VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_STATE_SET (
    PERMID VARCHAR(38),
    USERID VARCHAR(38),
    RESID VARCHAR(38),
    STATE INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_LIST (
    PARENTID VARCHAR(38))
RETURNS (
    POLID VARCHAR(38),
    NAME VARCHAR(50),
    RES_PROVID VARCHAR(38))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_RESET (
    POLID_ VARCHAR(38))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_STATE_GET (
    POLID VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_STATE_SET (
    POLID VARCHAR(38),
    STATE INTEGER)
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_CHECK (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_CHECK_ (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_CHECK__ (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38),
    RES_PARENT_SQL_ VARCHAR(1024))
RETURNS (
    STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_DEMAND (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
AS
BEGIN
  EXIT;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_DEMAND_USERS (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    USERID VARCHAR(38))
AS
BEGIN
  SUSPEND;
END^





CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_DEMAND2 (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
BEGIN
  SUSPEND;
END^






SET TERM ; ^



/******************************************************************************/
/***                                 Tables                                 ***/
/******************************************************************************/



CREATE TABLE BFW_SEC_ACL (
    PERMID  VARCHAR(38) NOT NULL,
    USERID  VARCHAR(38) NOT NULL,
    RESID   VARCHAR(38) NOT NULL,
    STATE   INTEGER NOT NULL
);


CREATE TABLE BFW_SEC_PERMISSIONS (
    PERMID             VARCHAR(38) NOT NULL,
    NAME               VARCHAR(50) NOT NULL,
    POLID              VARCHAR(38) NOT NULL,
    INHERITBY          VARCHAR(38),
    INHERITBY_RES_SQL  VARCHAR(1024),
    DESCRIPTION        VARCHAR(250)
);


CREATE TABLE BFW_SEC_POLICIES (
    POLID           VARCHAR(38) NOT NULL,
    NAME            VARCHAR(50) NOT NULL,
    PARENTID        VARCHAR(38),
    STATE           INTEGER NOT NULL,
    USE_RES         INTEGER NOT NULL,
    RES_PROVID      VARCHAR(38),
    RES_PARENT_SQL  VARCHAR(1024)
);


CREATE TABLE BFW_SEC_PROV (
    URI         VARCHAR(50) NOT NULL,
    ENTITYNAME  VARCHAR(50) NOT NULL
);


CREATE TABLE BFW_SEC_USER_ROLES (
    USERID  VARCHAR(38) NOT NULL,
    ROLEID  VARCHAR(38) NOT NULL
);


CREATE TABLE BFW_SEC_USERS (
    USERID  VARCHAR(38) NOT NULL,
    NAME    VARCHAR(50) NOT NULL,
    ISROLE  INTEGER DEFAULT 0 NOT NULL
);


INSERT INTO BFW_ENT (ENTITYNAME, SCHEMENAME, IS_SCHEME, DESCRIPTION) VALUES ('BFW_SEC_PERM', 'BFW_SEC', 0, NULL);
INSERT INTO BFW_ENT (ENTITYNAME, SCHEMENAME, IS_SCHEME, DESCRIPTION) VALUES ('BFW_SEC_POLICY', 'BFW_SEC', 0, NULL);
INSERT INTO BFW_ENT (ENTITYNAME, SCHEMENAME, IS_SCHEME, DESCRIPTION) VALUES ('BFW_SEC_PROV', 'BFW_SEC', 0, NULL);
INSERT INTO BFW_ENT (ENTITYNAME, SCHEMENAME, IS_SCHEME, DESCRIPTION) VALUES ('BFW_SEC_USER', 'BFW_SEC', 0, NULL);

COMMIT WORK;

INSERT INTO BFW_ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC, SQL_INSERTDEF) VALUES ('BFW_SEC_POLICY', 'List', 'select * from bfw_sec_ev_policy_list(:ParentID) order by name', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0, NULL);
INSERT INTO BFW_ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC, SQL_INSERTDEF) VALUES ('BFW_SEC_USER', 'List', 'select userid, name, isrole from bfw_sec_users order by name', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0, NULL);
INSERT INTO BFW_ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC, SQL_INSERTDEF) VALUES ('BFW_SEC_PERM', 'List', 'select * from bfw_sec_ev_perm_list(:polid)', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0, NULL);
INSERT INTO BFW_ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC, SQL_INSERTDEF) VALUES ('BFW_SEC_USER', 'Item', 'select userid, name, isrole from bfw_sec_users where userid= :userid', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0, NULL);
INSERT INTO BFW_ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC, SQL_INSERTDEF) VALUES ('BFW_SEC_PERM', 'Effective', 'select * from bfw_sec_ev_perm_effective(:polid, :permid, :resid)', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0, NULL);
INSERT INTO BFW_ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC, SQL_INSERTDEF) VALUES ('BFW_SEC_PROV', 'List', 'select * from bfw_sec_prov', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0, NULL);
INSERT INTO BFW_ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC, SQL_INSERTDEF) VALUES ('BFW_SEC_USER', 'UserRoleCheck', 'select count(*) status from bfw_sec_user_roles  where userid = :userid and roleid = :roleid', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0, NULL);
INSERT INTO BFW_ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC, SQL_INSERTDEF) VALUES ('BFW_SEC_PERM', 'StateGet', 'select state from bfw_sec_ev_perm_state_get(:permid, :userid, :resid)', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0, NULL);
INSERT INTO BFW_ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC, SQL_INSERTDEF) VALUES ('BFW_SEC_POLICY', 'StateGet', 'select state from bfw_sec_ev_policy_state_get(:polid)', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0, NULL);
INSERT INTO BFW_ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC, SQL_INSERTDEF) VALUES ('BFW_SEC_PERM', 'StateSet', 'execute procedure bfw_sec_ev_perm_state_set(:permid, :userid, :resid, :state)', NULL, NULL, NULL, NULL, 1, NULL, NULL, 1, NULL);
INSERT INTO BFW_ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC, SQL_INSERTDEF) VALUES ('BFW_SEC_POLICY', 'StateSet', 'execute procedure bfw_sec_ev_policy_state_set(:polid, :state)', NULL, NULL, NULL, NULL, 1, NULL, NULL, 1, NULL);
INSERT INTO BFW_ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC, SQL_INSERTDEF) VALUES ('BFW_SEC_USER', 'UserRoleAdd', 'insert into bfw_sec_user_roles(userid, roleid) values(:userid, :roleid)', NULL, NULL, NULL, NULL, 1, NULL, NULL, 1, NULL);
INSERT INTO BFW_ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC, SQL_INSERTDEF) VALUES ('BFW_SEC_USER', 'UserRoleRemove', 'delete from bfw_sec_user_roles where userid = :userid and roleid = :roleid', NULL, NULL, NULL, NULL, 1, NULL, NULL, 1, NULL);
INSERT INTO BFW_ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC, SQL_INSERTDEF) VALUES ('BFW_SEC_PERM', 'Check', 'select state from bfw_sec_sp_perm_check(:permid, :userid, :resid)', NULL, NULL, NULL, NULL, 1, NULL, NULL, 0, NULL);
INSERT INTO BFW_ENT_VIEWS (ENTITYNAME, VIEWNAME, SQL_SELECT, SQL_INSERT, SQL_UPDATE, SQL_DELETE, SQL_REFRESH, READONLY, PKEY, OPTIONS, IS_EXEC, SQL_INSERTDEF) VALUES ('BFW_SEC_POLICY', 'Reset', 'execute procedure bfw_sec_ev_policy_reset(:polid)', NULL, NULL, NULL, NULL, 1, NULL, NULL, 1, NULL);

COMMIT WORK;

INSERT INTO BFW_SEC_USERS (USERID, NAME, ISROLE) VALUES ('SYSDBA', 'Админ. БД', 0);

COMMIT WORK;

INSERT INTO BFW_SEC_POLICIES (POLID, NAME, PARENTID, STATE, USE_RES, RES_PROVID, RES_PARENT_SQL) VALUES ('APP.ACTIVITIES', 'Доступ к функциям программы', NULL, 1, 1, 'security.resprovider.app.activities', NULL);
INSERT INTO BFW_SEC_POLICIES (POLID, NAME, PARENTID, STATE, USE_RES, RES_PROVID, RES_PARENT_SQL) VALUES ('ADMIN', 'Административные разрешения', NULL, 1, 0, NULL, NULL);

COMMIT WORK;

INSERT INTO BFW_SEC_PERMISSIONS (PERMID, NAME, POLID, INHERITBY, INHERITBY_RES_SQL, DESCRIPTION) VALUES ('app.activity.execute', 'Выполнить', 'APP.ACTIVITIES', NULL, NULL, NULL);
INSERT INTO BFW_SEC_PERMISSIONS (PERMID, NAME, POLID, INHERITBY, INHERITBY_RES_SQL, DESCRIPTION) VALUES ('builtin.unrestricted', 'Неограниченный доступ', 'ADMIN', NULL, NULL, NULL);

COMMIT WORK;

INSERT INTO BFW_SEC_ACL (PERMID, USERID, RESID, STATE) VALUES ('builtin.unrestricted', 'SYSDBA', '', 1);

COMMIT WORK;



/******************************************************************************/
/***                              Primary Keys                              ***/
/******************************************************************************/

ALTER TABLE BFW_SEC_ACL ADD CONSTRAINT PK_BFW_SEC_ACL PRIMARY KEY (PERMID, USERID, RESID);
ALTER TABLE BFW_SEC_PERMISSIONS ADD CONSTRAINT PK_BFW_SEC_PERMISSIONS PRIMARY KEY (PERMID);
ALTER TABLE BFW_SEC_POLICIES ADD CONSTRAINT PK_BFW_SEC_POLICIES PRIMARY KEY (POLID);
ALTER TABLE BFW_SEC_PROV ADD CONSTRAINT PK_BFW_SEC_PROV PRIMARY KEY (URI);
ALTER TABLE BFW_SEC_USERS ADD CONSTRAINT PK_BFW_SEC_USERS PRIMARY KEY (USERID);
ALTER TABLE BFW_SEC_USER_ROLES ADD CONSTRAINT PK_BFW_SEC_USER_ROLES PRIMARY KEY (USERID, ROLEID);


/******************************************************************************/
/***                              Foreign Keys                              ***/
/******************************************************************************/

ALTER TABLE BFW_SEC_ACL ADD CONSTRAINT FK_BFW_SEC_ACL_PERM FOREIGN KEY (PERMID) REFERENCES BFW_SEC_PERMISSIONS (PERMID);
ALTER TABLE BFW_SEC_ACL ADD CONSTRAINT FK_BFW_SEC_ACL_USERID FOREIGN KEY (USERID) REFERENCES BFW_SEC_USERS (USERID);
ALTER TABLE BFW_SEC_PERMISSIONS ADD CONSTRAINT FK_BFW_SEC_PERMISSIONS_INHERITB FOREIGN KEY (INHERITBY) REFERENCES BFW_SEC_PERMISSIONS (PERMID);
ALTER TABLE BFW_SEC_PERMISSIONS ADD CONSTRAINT FK_BFW_SEC_PERMISSIONS_POLID FOREIGN KEY (POLID) REFERENCES BFW_SEC_POLICIES (POLID);
ALTER TABLE BFW_SEC_POLICIES ADD CONSTRAINT FK_BFW_SEC_POLICIES_PARENT FOREIGN KEY (PARENTID) REFERENCES BFW_SEC_POLICIES (POLID);
ALTER TABLE BFW_SEC_USER_ROLES ADD CONSTRAINT FK_BFW_SEC_USER_ROLES_ROLEID FOREIGN KEY (ROLEID) REFERENCES BFW_SEC_USERS (USERID);
ALTER TABLE BFW_SEC_USER_ROLES ADD CONSTRAINT FK_BFW_SEC_USER_ROLES_USERID FOREIGN KEY (USERID) REFERENCES BFW_SEC_USERS (USERID);


/******************************************************************************/
/***                                Triggers                                ***/
/******************************************************************************/


SET TERM ^ ;



/******************************************************************************/
/***                          Triggers for tables                           ***/
/******************************************************************************/



/* Trigger: BFW_SEC_PERMISSIONS_BD */
CREATE OR ALTER TRIGGER BFW_SEC_PERMISSIONS_BD FOR BFW_SEC_PERMISSIONS
ACTIVE BEFORE DELETE POSITION 0
as
begin
  delete from bfw_sec_acl a where a.permid = old.permid;
end
^


/* Trigger: BFW_SEC_POLICIES_BD */
CREATE OR ALTER TRIGGER BFW_SEC_POLICIES_BD FOR BFW_SEC_POLICIES
ACTIVE BEFORE DELETE POSITION 0
as
begin
  if (old.polid = 'BUILD-IN') then
    exception bfw_sec_raise 'It is not allowed for built-in policy';
end
^


/* Trigger: BFW_SEC_POLICIES_BU */
CREATE OR ALTER TRIGGER BFW_SEC_POLICIES_BU FOR BFW_SEC_POLICIES
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.polid = 'BUILT-IN' and new.state <> old.state and new.state = 0) then
    exception bfw_sec_raise 'It is not allowed for built-in policy';
end
^


/* Trigger: BFW_SEC_USERS_BD */
CREATE OR ALTER TRIGGER BFW_SEC_USERS_BD FOR BFW_SEC_USERS
ACTIVE BEFORE DELETE POSITION 0
as
begin
  delete from bfw_sec_acl a where a.userid = old.userid;
  delete from bfw_sec_user_roles r where r.userid = old.userid;
  delete from bfw_sec_user_roles r where r.roleid = old.userid;
end
^


/* Trigger: BFW_SEC_USERS_BI */
CREATE OR ALTER TRIGGER BFW_SEC_USERS_BI FOR BFW_SEC_USERS
ACTIVE BEFORE INSERT POSITION 0
as
begin
  if (new.name is null) then
    new.name = new.userid;
end
^


/* Trigger: BFW_SEC_USERS_BU */
CREATE OR ALTER TRIGGER BFW_SEC_USERS_BU FOR BFW_SEC_USERS
ACTIVE BEFORE UPDATE POSITION 0
as
begin
  if (new.name is null) then
    new.name = new.userid;
end
^


SET TERM ; ^



/******************************************************************************/
/***                           Stored Procedures                            ***/
/******************************************************************************/


SET TERM ^ ;

CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_EFFECTIVE (
    POLID_ VARCHAR(38),
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    USERID VARCHAR(38),
    USERNAME VARCHAR(50),
    PERM VARCHAR(50),
    STATE INTEGER,
    INHERITBY_POLID VARCHAR(38),
    INHERITBY_PERM VARCHAR(100),
    INHERITBY_RESID VARCHAR(38))
AS
declare variable permcheck varchar(38);
declare variable permid varchar(38);
declare variable resid varchar(38);
begin
  permid_ = nullif(permid_, '');
  for
    select userid, name
    from bfw_sec_users
    into :userid, :username
  do begin
    for
      select p.permid, p.name
      from bfw_sec_policies pl left join bfw_sec_permissions p  on (pl.polid = p.polid)
      where pl.polid = :polid_
            and ((:permid_ is null) or (:permid_ is not null and p.permid = :permid_))
      into :permcheck, :perm
    do begin
      state = null;
      inheritby_perm = null;
      inheritby_resid = null;
      permid = null;
      resid = null;
      for
        select distinct p.state, p.permid, p.resid
        from bfw_sec_ev_perm_effective_(:permcheck, :userid, :resid_) p
        into :state, :permid, :resid
      do begin
        select polid from bfw_sec_permissions where permid = :permid
        into :inheritby_polid;

        inheritby_resid = null;
        inheritby_perm = null;
        if (permid <> permcheck) then
        begin
          select pl.name || ' \ ' || p.name
          from bfw_sec_permissions p
               left join bfw_sec_policies pl on (p.polid = pl.polid)
          where p.permid = :permid
          into :inheritby_perm;
        end

        if (coalesce(resid, resid_) <> resid_) then
          inheritby_resid = resid;

        suspend;
      end
    end
  end
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_EFFECTIVE_ (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER,
    PERMID VARCHAR(38),
    RESID VARCHAR(38))
AS
declare variable INHERITBY varchar(38);
declare variable INHERITBY_RES_SQL varchar(1024);
declare variable INHERITBY_RESID varchar(38);
declare variable RES_PARENT_SQL varchar(1024);
begin
  resid_ = coalesce(resid_, '');
  permid = permid_;
  resid = resid_;

  select p.inheritby, p.inheritby_res_sql, pol.res_parent_sql
  from bfw_sec_permissions p left join bfw_sec_policies pol on (pol.polid = p.polid)
  where p.permid = :permid_
  into :inheritby, :inheritby_res_sql, :res_parent_sql;

  for
    select state, permid, resid
    from bfw_sec_ev_perm_effective__(:permid_, :userid_, :resid_, :res_parent_sql)
    into :state, :permid, :resid
  do
    suspend;

  if (resid_ <> '') then -- check for all items
  begin
    resid = '';
    select a.state
    from bfw_sec_acl a
    where a.userid = :userid_ and a.permid = :permid_ and a.resid = ''
    into :state;
    if (state in (1, 2)) then
      suspend;
  end

  if (inheritby is not null) then
  begin
    inheritby_resid = null;
    if (coalesce(inheritby_res_sql, '') <> '' and resid_ <> '') then
    begin
      inheritby_res_sql = inheritby_res_sql || :resid_;
      for execute statement inheritby_res_sql
          into :inheritby_resid
      do begin
        inheritby_resid = coalesce(inheritby_resid, '');
        for
          select state, permid, resid
          from bfw_sec_ev_perm_effective_(:inheritby, :userid_, :inheritby_resid)
          into :state, :permid, :resid
        do
          suspend;
      end
    end

    state = null;
    select state, permid, resid from bfw_sec_ev_perm_effective_(:inheritby, :userid_, null)
    into :state, :permid, :resid;
    if (state in (1, 2)) then
      suspend;

  end
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_EFFECTIVE__ (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38),
    RES_PARENT_SQL_ VARCHAR(1024))
RETURNS (
    STATE INTEGER,
    PERMID VARCHAR(38),
    RESID VARCHAR(38))
AS
declare variable parent_resid varchar(38);
declare variable res_parent_sql varchar(1024);
begin
  resid_ = coalesce(resid_, '');
  permid = permid_;

  resid = resid_;
  select a.state
  from bfw_sec_acl a
  where a.userid = :userid_ and a.permid = :permid_ and a.resid = :resid_
  into :state;
  if (state in (1, 2)) then
    suspend;

  if ((coalesce(res_parent_sql_, '') <> '') and resid_ <> '') then
  begin
    res_parent_sql = res_parent_sql_ || :resid_;
    execute statement res_parent_sql into :parent_resid;
    parent_resid = coalesce(parent_resid, '');

    if (parent_resid <> '') then
      for
        select state, permid, resid
        from bfw_sec_ev_perm_effective__(:permid_, :userid_, :parent_resid, :res_parent_sql_)
        into :state, :permid, :resid
      do
        suspend;

  end


end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_LIST (
    POLID VARCHAR(38))
RETURNS (
    PERMID VARCHAR(38),
    NAME VARCHAR(50),
    DESCRIPTION VARCHAR(250),
    INHERITBY VARCHAR(100))
AS
begin
  for
    select p.permid, p.name, p.description, pli.name || ' \ ' || pi.name
    from bfw_sec_permissions p
         left join bfw_sec_permissions pi on (p.inheritby = pi.permid)
         left join bfw_sec_policies pli on (pli.polid = pi.polid)
    where p.polid = :polid
    into :permid, :name, :description, :inheritby
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_STATE_GET (
    PERMID VARCHAR(38),
    USERID VARCHAR(38),
    RESID VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
begin
  resid = coalesce(resid, '');
  select state
  from bfw_sec_acl p
  where p.resid = :resid and p.userid = :userid and p.permid = :permid
  into :state;
  state = coalesce(state, 0);
  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_PERM_STATE_SET (
    PERMID VARCHAR(38),
    USERID VARCHAR(38),
    RESID VARCHAR(38),
    STATE INTEGER)
AS
begin
  resid = coalesce(resid, '');

  if (state = 0) then
    delete from bfw_sec_acl p
       where p.resid = :resid and p.userid = :userid and p.permid = :permid;
  else
  begin
    if (exists(select * from bfw_sec_acl p
              where p.resid = :resid
                    and p.userid = :userid and p.permid = :permid)) then
     update bfw_sec_acl p
     set p.state = :state
     where p.resid = :resid and p.userid = :userid and p.permid = :permid;
    else
      insert into bfw_sec_acl(resid, userid, permid, state)
      values (:resid, :userid, :permid, :state);
  end
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_LIST (
    PARENTID VARCHAR(38))
RETURNS (
    POLID VARCHAR(38),
    NAME VARCHAR(50),
    RES_PROVID VARCHAR(38))
AS
begin
  for
    select p.polid, p.name, p.res_provid
    from bfw_sec_policies p
    where p.parentid is null and coalesce(:parentid, '') = ''
    union all
    select p.polid, p.name, p.res_provid
    from bfw_sec_policies p
    where p.parentid = :parentid and coalesce(:parentid, '') <> ''
    into :polid, :name, :res_provid
  do
    suspend;
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_RESET (
    POLID_ VARCHAR(38))
AS
begin
  delete from bfw_sec_acl a
  where a.permid in (select p.permid from bfw_sec_permissions p where p.polid = :polid_);
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_STATE_GET (
    POLID VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
begin
  select state
  from bfw_sec_policies p where p.polid= :polid
  into :state;
  state = coalesce(state, 0);
  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_SEC_EV_POLICY_STATE_SET (
    POLID VARCHAR(38),
    STATE INTEGER)
AS
begin
  update bfw_sec_policies p
  set p.state = :state
  where p.polid = :polid;
end^


CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_CHECK (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
declare variable unrestricted_perm varchar(38) = 'builtin.unrestricted' ;
begin
  resid_ = coalesce(resid_, '');

-- check unrestricted user
  select a.state
  from bfw_sec_acl a
  where a.permid = :unrestricted_perm and a.userid = :userid_ and a.resid = ''
        and a.state = 1
  into :state;

  if (coalesce(state, 0) = 1) then
  begin
    suspend;
    exit;
  end

-- check unrestricted role
  select first 1 a.state
  from bfw_sec_acl a
       left join bfw_sec_user_roles r on (a.userid = r.roleid)
  where a.permid = :unrestricted_perm and r.userid = :userid_ and a.resid = ''
        and a.state = 1
  into :state;

  if (coalesce(state, 0) = 1) then
  begin
    suspend;
    exit;
  end

-- check all
  select state from bfw_sec_sp_perm_check_(:permid_, :userid_, :resid_)
  into :state;
  suspend;


end^


CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_CHECK_ (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
declare variable pol_state integer;
declare variable inheritby_permid varchar(38);
declare variable inheritby_resid varchar(38);
declare variable res_parent_sql varchar(1024);
declare variable inheritby_res_sql varchar(1024);
begin
  resid_ = coalesce(resid_, '');

-- check inactive policy
  select p.inheritby, p.inheritby_res_sql, pol.res_parent_sql, pol.state
  from bfw_sec_permissions p left join bfw_sec_policies pol on (pol.polid = p.polid)
  where p.permid = :permid_
  into :inheritby_permid, :inheritby_res_sql, :res_parent_sql, :pol_state;

  if (pol_state <> 1) then
  begin
    state = 1;
    suspend;
    exit;
  end

-- check item and parents

  select state from bfw_sec_sp_perm_check__(:permid_, :userid_, :resid_, :res_parent_sql)
  into :state;

  if (state in (1, 2)) then
  begin
    suspend;
    exit;
  end

  if (inheritby_permid is not null) then
  begin
    if ((coalesce(inheritby_res_sql, '') <> '') and resid_ <> '') then
    begin
      inheritby_res_sql = inheritby_res_sql || :resid_;
      for execute statement inheritby_res_sql
          into :inheritby_resid
      do begin
        inheritby_resid = coalesce(inheritby_resid, '');
        select state from bfw_sec_sp_perm_check_(:inheritby_permid, :userid_, :inheritby_resid)
        into :state;
        if (state in (1, 2)) then
        begin
          suspend;
          exit;
        end
      end
    end

    select state from bfw_sec_sp_perm_check_(:inheritby_permid, :userid_, null)
    into :state;
    suspend;
    exit;

  end


  state = 0;
  suspend;
end^


CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_CHECK__ (
    PERMID_ VARCHAR(38),
    USERID_ VARCHAR(38),
    RESID_ VARCHAR(38),
    RES_PARENT_SQL_ VARCHAR(1024))
RETURNS (
    STATE INTEGER)
AS
declare variable roleid varchar(38);
declare variable parent_resid varchar(38);
declare variable res_parent_sql varchar(1024);
begin

-- check user
  select a.state
  from bfw_sec_acl a
  where a.permid = :permid_ and a.userid = :userid_ and a.resid = :resid_
  into :state;

  if (state in (1, 2)) then
  begin
    suspend;
    exit;
  end

  if (resid_ <> '') then --check for all items
  begin
    select a.state
    from bfw_sec_acl a
    where a.permid = :permid_ and a.userid = :userid_ and a.resid = ''
    into :state;

    if (state in (1, 2)) then
    begin
      suspend;
      exit;
    end
  end



-- check for roles
  for
    select r.roleid
    from bfw_sec_user_roles r
    where r.userid = :userid_
    into :roleid
  do begin
    select a.state
    from bfw_sec_acl a
    where a.userid = :roleid and a.permid = :permid_ and a.resid = :resid_
    into :state;

    if (state in (1, 2)) then
    begin
      suspend;
      exit;
    end
  end

  if (resid_ <> '') then -- check for all items
  begin
    for
      select r.roleid
      from bfw_sec_user_roles r
      where r.userid = :userid_
      into :roleid
    do begin
      select a.state
      from bfw_sec_acl a
      where a.userid = :roleid and a.permid = :permid_ and a.resid = ''
      into :state;

      if (state in (1, 2)) then
      begin
        suspend;
        exit;
      end
    end
  end

-- check parent res

  if ((coalesce(res_parent_sql_, '') <> '') and resid_ <> '') then
  begin
    res_parent_sql = res_parent_sql_ || :resid_;
    execute statement res_parent_sql into :parent_resid;

    if (coalesce(parent_resid, '') <> '') then
      select p.state
      from bfw_sec_sp_perm_check__(:permid_, :userid_, :parent_resid, :res_parent_sql_) p
      into :state;
  end

  state = coalesce(state, 0);
  suspend;

end^


CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_DEMAND (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
AS
declare variable userid  varchar(38);
declare variable pstate integer;
declare variable pname varchar(250);
begin
  userid = user;
  select state from bfw_sec_sp_perm_check(:permid_, :userid, :resid_)
  into :pstate;

  if (pstate <> 1) then
  begin
    select name from bfw_sec_permissions p where p.permid = :permid_
    into :pname;

    pname = coalesce(pname, permid_);

    pname = 'No permission for: ' || pname;
    exception bfw_sec_raise :pname;

  end
end^


CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_DEMAND_USERS (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    USERID VARCHAR(38))
AS
declare variable state integer;
begin
  for
    select u.userid
    from bfw_sec_users u
    where u.isrole = 0
    into :userid 
  do begin
    select state from bfw_sec_sp_perm_check(:permid_, :userid, :resid_)
    into :state;

    if (state = 1) then suspend;
  end
end^


CREATE OR ALTER PROCEDURE BFW_SEC_SP_PERM_DEMAND2 (
    PERMID_ VARCHAR(38),
    RESID_ VARCHAR(38))
RETURNS (
    STATE INTEGER)
AS
declare variable userid  varchar(38);
begin
  userid = user;
  select state from bfw_sec_sp_perm_check(:permid_, :userid, :resid_)
  into :state;
  suspend;
end^



SET TERM ; ^


/******************************************************************************/
/***                          Fields descriptions                           ***/
/******************************************************************************/

DESCRIBE FIELD INHERITBY_RES_SQL TABLE BFW_SEC_PERMISSIONS
'format sql statement:
select cast(t.fieldname as varchar(38)) from tablename t where t.fieldname=';

DESCRIBE FIELD RES_PARENT_SQL TABLE BFW_SEC_POLICIES
'format sql statement:
select cast(t.parentfieldname as varchar(38)) from tablename t where t.fieldname=';

